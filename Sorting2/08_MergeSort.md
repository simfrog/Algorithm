# 05. 병합 정렬(Merge Sort)  

## 1. 개념  
### '분할 정복' 알고리즘  
### 정확히 반으로 나누고 나중에 정렬하는 알고리즘  
하나의 큰 문제를 두개의 작은 문제로 분할한 뒤 각자 계산하고 나중에 합치는 방법  
![병합정렬](https://user-images.githubusercontent.com/31130917/105665354-33eeab80-5f1a-11eb-9d49-a5de4f6dcd24.png)  
<출처 : https://gmlwjd9405.github.io/2018/05/08/algorithm-merge-sort.html>  
  
퀵 정렬과 다르게 pivot 값이 없고 항상 반으로 나눔  
합치는 순간에 정렬을 수행  
합치는 개수가 2배씩 증가하기 때문에 2^3=8 -> log2^3  
=> 합치는 단계는 3단계만 필요  
### 데이터의 개수가 N개일 때 logN을 유지  
### 정렬 자체에 필요한 수행시간은 N
### 따라서 시간 복잡도는 O(N*logN)  
  
![스크린샷(16)](https://user-images.githubusercontent.com/31130917/105666413-85983580-5f1c-11eb-9b92-7f16392f885e.png)  
![스크린샷(14)](https://user-images.githubusercontent.com/31130917/105666418-86c96280-5f1c-11eb-84d5-fb26dce020af.png)  
![스크린샷(15)](https://user-images.githubusercontent.com/31130917/105666423-88932600-5f1c-11eb-9016-389463c64c2e.png)  
  
### 부분 집합은 이미 정렬되어 있는 상태라고 가정  
### 따라서 이미 정렬이 되어있는 것 두 개를 합치는 것은 시간복잡도가 O(N)이면 충분  

## 2. 시간 복잡도  
반으로 분할 -> logN, 정렬되어 있는 것을 합침 -> N
### => 병합 정렬의 평균 시간 복잡도는 O(N*logN)  

## 3. 특징  
퀵 정렬은 pivot 값에 따라 편향되게 분할할 가능성이 있다는 점에서 최악의 경우 O(N^2)이 나옴  
하지만 병합 정렬은 정확히 반으로 나누기 때문에  
### 최악의 경우에도 O(N*logN)을 보장  
(물론 그렇다고 퀵 정렬보다 빠르다는 것은 아님)  
  
구현시 반드시 정렬에 사용되는 배열은 '전역 변수'로 선언  
함수 안에서 배열을 선언하게 되면 매 번 배열을 선언해야 한다는 점에서 메모리 자원의 낭비가 매우 커질 수 있음  
### '기존의 데이터를 담을 추가적인 배열 공간이 필요하다는 점'에서 메모리 활용이 비효율적